# 2025-08-21 Work Session

## Context

- Project: [[AreYouJ]]
- Focus Area: Claude Code 통합 방식 분석 및 모바일 알림 시스템 개선 방안 도출
- Session Type: 아키텍처 분석 및 개선 전략 수립

## Major Analysis Completed

### Omnara vs AreYouJ Claude Code 통합 방식 비교 분석

#### AreYouJ: PTY 기반 직접 제어 방식

**특징**:
- 터미널 프로세스를 PTY(Pseudo Terminal)로 직접 제어
- Claude와의 통신이 단일 레이어로 구성됨
- 실시간 터미널 출력을 WebSocket을 통해 프론트엔드로 스트리밍

**장점**:
- **직접성**: 중간 레이어 없이 바로 Claude 프로세스 제어
- **실시간성**: 터미널 출력의 즉각적인 전달
- **단순성**: 아키텍처가 상대적으로 단순함
- **투명성**: 모든 Claude 출력을 그대로 확인 가능

**단점**:
- **원시 출력**: 터미널 제어 문자와 함께 복잡한 출력
- **구조화 부족**: 의미있는 이벤트 추출이 어려움
- **알림 한계**: 특정 상황 감지가 제한적
- **확장성**: 다중 에이전트 관리가 복잡함

#### Omnara: Wrapper + MCP 이중 구조 방식

**특징**:
- Claude 래퍼 + MCP(Model Context Protocol) 이중 레이어
- 구조화된 메시지 시스템 (log_step, ask_question 패턴)
- PostgreSQL 기반 중앙집중식 데이터 관리

**장점**:
- **구조화**: 의미있는 메시지 패턴으로 이벤트 분류
- **알림 시스템**: requires_user_input → AWAITING_INPUT 플로우
- **확장성**: 다중 에이전트와 프로젝트 관리 용이
- **모니터링**: 체계적인 상태 추적 및 로깅

**단점**:
- **복잡성**: 더 많은 레이어와 의존성
- **간접성**: Claude와 사용자 사이의 추상화 레이어
- **오버헤드**: PostgreSQL 등 무거운 인프라 요구
- **설정 복잡도**: 초기 설정과 유지보수 부담

#### 핵심 차이점 요약

| 측면 | AreYouJ (PTY 직접) | Omnara (Wrapper+MCP) |
|------|-------------------|---------------------|
| **구조** | 단순, 직접적 | 복잡, 계층화 |
| **출력** | 원시 터미널 출력 | 구조화된 메시지 |
| **알림** | 제한적 | 체계적 시스템 |
| **확장성** | 제한적 | 높음 |
| **설정** | 간단 | 복잡 |

## User Requirements Analysis

사용자가 원하는 **3가지 핵심 개선사항**:

### 1. 모바일에서 Claude 질문/완료 알림 받기

**현재 상황**:
- AreYouJ는 터미널 출력만 스트리밍
- 특정 이벤트(질문, 완료) 감지 로직 부재

**Omnara 해결책**:
- `requires_user_input: true` → `AWAITING_INPUT` 상태 변경
- PostgreSQL 트리거 → Expo Push 알림 시스템
- 구조화된 메시지로 이벤트 분류

### 2. 복잡한 터미널 출력 대신 간소화된 모니터링

**현재 문제점**:
- ANSI 제어 문자, 프로그래스 바 등 노이즈 많음
- 핵심 정보 파악이 어려움

**개선 방향**:
- 메시지 패턴 매칭으로 의미있는 이벤트만 추출
- 시각적으로 정리된 상태 표시
- 진행 상황의 구조화된 표현

### 3. 원격 모니터링과 다중 프로젝트/에이전트 관리

**현재 한계**:
- 단일 프로젝트/세션만 지원
- 원격 접근 기능 없음

**확장 필요사항**:
- 여러 프로젝트 동시 모니터링
- 각 에이전트별 독립적 상태 관리
- 원격에서 상태 확인 및 제어

## Omnara 핵심 구현 방식 분석

### 알림 시스템 플로우

```
1. Agent가 사용자 입력 필요 시점에서 ask_question() 호출
2. requires_user_input: true로 메시지 저장
3. Message 상태가 AWAITING_INPUT으로 변경
4. PostgreSQL 트리거가 상태 변경 감지
5. 트리거에서 push_notifications 테이블에 알림 생성
6. Expo Push 서비스를 통해 모바일 알림 발송
```

### 메시지 구조화 패턴

**log_step() 패턴**:
```javascript
await logStep('authentication', 'SUCCESS', 'JWT token validated');
await logStep('database', 'INFO', 'Connecting to PostgreSQL...');
```

**ask_question() 패턴**:
```javascript
const response = await askQuestion(
  'Should I proceed with database migration?',
  ['yes', 'no', 'cancel']
);
```

### 데이터베이스 설계

**핵심 테이블**:
- `UserAgent`: 사용자별 에이전트 설정
- `AgentInstance`: 실행 중인 에이전트 인스턴스
- `Message`: 구조화된 메시지 로그
- `PushToken`: 모바일 푸시 토큰 관리

## AreYouJ 적용 방안 제안

### Phase 1: 메시지 구조화 및 패턴 매칭

**구현 계획**:
1. **터미널 출력 파싱**: 기존 PTY 출력에서 의미있는 패턴 추출
2. **이벤트 분류기**: 정규표현식/패턴 매칭으로 메시지 타입 분류
3. **상태 기계**: 에이전트 상태(실행중, 대기중, 완료) 추적

**예상 패턴**:
```javascript
const patterns = {
  question: /I need your input:|Please choose:|Should I/,
  completion: /Task completed|Finished|Done/,
  error: /Error:|Failed:|Exception/,
  progress: /Progress:|Step \d+:|Working on/
};
```

### Phase 2: SQLite 스키마 확장

**새 테이블 설계**:
```sql
-- 에이전트 인스턴스 관리
CREATE TABLE agent_instances (
  id INTEGER PRIMARY KEY,
  project_path TEXT NOT NULL,
  status TEXT DEFAULT 'RUNNING', -- RUNNING, WAITING, COMPLETED, ERROR
  started_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  last_activity DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- 구조화된 메시지
CREATE TABLE structured_messages (
  id INTEGER PRIMARY KEY,
  agent_id INTEGER REFERENCES agent_instances(id),
  type TEXT NOT NULL, -- question, completion, error, info
  content TEXT NOT NULL,
  requires_input BOOLEAN DEFAULT FALSE,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- 푸시 토큰 관리
CREATE TABLE push_tokens (
  id INTEGER PRIMARY KEY,
  token TEXT UNIQUE NOT NULL,
  platform TEXT, -- web, ios, android
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);
```

### Phase 3: PWA 브라우저 알림 시스템

**웹 푸시 알림 구현**:
1. **Service Worker**: 백그라운드 알림 수신
2. **Push API**: 브라우저 네이티브 알림
3. **알림 권한**: 사용자 동의 플로우
4. **구독 관리**: 푸시 토큰 등록/해제

**예상 구현**:
```javascript
// Service Worker에서 알림 처리
self.addEventListener('push', event => {
  const data = event.data.json();
  const options = {
    body: data.message,
    icon: '/icons/claude-icon.png',
    badge: '/icons/badge.png',
    tag: `agent-${data.agentId}`,
    requireInteraction: data.type === 'question'
  };
  
  event.waitUntil(
    self.registration.showNotification(data.title, options)
  );
});
```

### Phase 4: 간소화된 대시보드 UI

**UI 개선 방향**:
1. **상태 카드**: 각 에이전트별 현재 상태 요약
2. **이벤트 타임라인**: 중요 이벤트만 시간순 표시
3. **인터랙션 큐**: 사용자 응답이 필요한 질문들 모음
4. **진행률 표시**: 작업 단계별 진행 상황

## Technical Decisions Made

### 아키텍처 방향성 결정

**Choice**: 기존 PTY 방식 유지 + 상위 레이어 추가
**Reasoning**: 
- 기존 시스템의 장점(직접성, 투명성) 보존
- Omnara의 구조화 장점을 상위 레이어로 추가
- 점진적 개선 가능

**Alternatives Considered**:
- 완전한 Wrapper 방식 전환: 기존 코드 대폭 수정 필요
- 현상 유지: 사용자 요구사항 해결 불가

### 데이터베이스 선택

**Choice**: 기존 SQLite 유지 및 확장
**Reasoning**:
- 로컬 환경에 적합한 경량 솔루션
- 기존 시스템과의 호환성
- PostgreSQL 대비 설정 부담 적음

## Discovered Patterns

### 사용자 니즈 패턴
- **모바일 중심**: 데스크톱에 붙어있지 않고도 상태 확인하고 싶어함
- **간소화 선호**: 복잡한 기술적 세부사항보다 핵심 정보 원함
- **멀티태스킹**: 여러 프로젝트를 동시에 관리하고 싶어함

### 아키텍처 트레이드오프 패턴
- **직접성 vs 구조화**: 단순함과 기능성 사이의 균형점 필요
- **로컬 vs 클라우드**: 설정 간편함과 확장성 사이의 선택
- **실시간 vs 배치**: 즉시성과 시스템 부하 사이의 조율

## Next Session Planning

### 우선순위 태스크

- [ ] **Phase 1 구현**: 터미널 출력 패턴 매칭 및 이벤트 분류기 개발
- [ ] **SQLite 스키마**: 확장된 테이블 구조 설계 및 마이그레이션
- [ ] **PWA 설정**: Service Worker 및 푸시 알림 기본 구조 구현
- [ ] **UI 목업**: 간소화된 대시보드 디자인 프로토타입

### 검토 질문

- 기존 WebSocket 아키텍처와 새로운 알림 시스템의 통합 방식?
- PWA vs 네이티브 앱의 트레이드오프 재검토 필요?
- 다중 프로젝트 관리 시 성능 이슈 예방책?

### 학습 노트

- **Omnara 분석**: MCP 패턴의 메시지 구조화가 핵심 인사이트
- **패턴 매칭**: 비구조화 데이터에서 의미 추출하는 실용적 접근법
- **점진적 개선**: 기존 시스템 장점 보존하며 새 기능 추가하는 전략

## Context for Next Session

**현재 상태**: 
- Omnara vs AreYouJ 아키텍처 분석 완료
- 사용자 요구사항 구체화 완료  
- 4단계 구현 로드맵 수립 완료

**다음 작업**: Phase 1 구현부터 시작하여 터미널 출력 패턴 매칭 및 이벤트 분류 시스템 개발

**중요 인사이트**: 기존 PTY 직접 제어 방식의 장점을 유지하면서 Omnara의 구조화된 메시지 시스템 아이디어를 상위 레이어로 추가하는 하이브리드 접근법이 최적