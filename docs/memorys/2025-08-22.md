# 2025-08-22 Work Session

## Context

- Project: [[AreYouJ]]
- Focus Area: Dynamic Session Orchestration Architecture Plan
- Previous Session: Initial architecture planning session
- **MAJOR PIVOT**: From project-based to dynamic session orchestration approach

## Architecture Analysis & Planning

### Current System Limitations

#### Single Session Architecture
- **Current State**: 단일 Claude 세션만 지원
  - 하나의 working directory에 제한
  - 하나의 메시지 큐만 처리 가능
  - 프로젝트 간 컨텍스트 충돌 위험
- **Files**: `server/claude/session-manager.js:8-161`
- **WebSocket**: 단일 세션 이벤트만 처리

#### Scalability Issues
- **Resource Competition**: 여러 프로젝트 동시 작업 시 리소스 경합
- **Context Mixing**: 프로젝트별 컨텍스트 분리 불가
- **Queue Management**: 우선순위 기반 작업 스케줄링 부재

## Technical Decisions

### Dynamic Session Orchestration Architecture Design

#### Choice: SessionOrchestrator + Dynamic Session Management
- **Reasoning**:
  - **Dynamic Sessions**: 사용자가 어떤 디렉토리에서든 Claude 세션 시작 가능
  - **No Fixed Mapping**: 프로젝트-세션 고정 매핑 없음, 완전히 동적
  - **Persistent Sessions**: 수동 종료 또는 서버 셧다운까지 세션 지속 (타임아웃 없음)
  - **Central Orchestration**: 모든 활성 세션의 중앙 모니터링 및 관리

#### Architecture Components

**1. SessionOrchestrator Layer**
```javascript
SessionOrchestrator {
  activeSessions: Map<sessionId, ClaudeSession>
  createSession(workingDirectory, userConfig)
  terminateSession(sessionId)
  getAllActiveSessions()
  getSessionDetails(sessionId)
}
```

**2. Dynamic Session Model**
```javascript
SessionInstance {
  id: string (UUID)
  workingDirectory: string
  startTime: Date
  status: 'running' | 'idle' | 'busy'
  currentTask: string
  messageQueue: Queue
  claudeProcess: PTY
}
```

**3. Orchestration UI Components**
```javascript
OrchestrationPage {
  // Statistics (like Automation's message queue stats)
  sessionStats: { total, running, idle, busy }
  
  // Start Session Button → DirectoryBrowser
  startSessionButton: () => DirectoryBrowser
  
  // Active Sessions Table
  sessionsTable: {
    columns: [sessionId, path, startTime, status, currentTask, actions]
    actions: [stopButton, viewDetailsLink]
  }
}
```

#### Alternatives Considered
- **Fixed Project-Session Mapping**: 
  - 장점: 구조화된 관리, 예측 가능한 리소스 사용
  - 단점: 유연성 부족, 사용자 워크플로우 제약
- **Single Session with Directory Switching**:
  - 장점: 리소스 효율적
  - 단점: 컨텍스트 오염, 동시 작업 불가

#### Impact Assessment
- **Performance**: 메모리 사용량 증가 (세션당 ~50MB), 타임아웃 없는 지속성
- **Flexibility**: 완전히 동적인 세션 생성으로 사용자 워크플로우 자유도 극대화
- **Maintainability**: 중앙화된 오케스트레이션으로 관리 복잡성 감소
- **User Experience**: 어떤 디렉토리에서든 즉시 세션 시작, 동시 다중 작업 가능

## Implementation Plan

### Phase 1: Core Orchestration Infrastructure (Week 1-2)
- [ ] SessionOrchestrator 구현
  - `server/orchestration/session-orchestrator.js` 생성
  - 동적 세션 생성/종료 로직
  - 세션 상태 모니터링 (no timeout)
  - UUID 기반 세션 ID 관리
- [ ] Dynamic Session Model 구현
  - `server/orchestration/session-instance.js` 생성
  - 독립적인 메시지 큐 관리
  - 세션별 PTY 프로세스 격리
- [ ] Database Schema 설계
  - `active_sessions` 테이블 추가
  - 세션 메타데이터 영속화 (재시작 시 복구용)

### Phase 2: Orchestration UI (Week 3)
- [ ] Orchestration Page 구현
  - Automation 스타일의 통계 대시보드
  - "Start Session" 버튼 → DirectoryBrowser 통합
  - 활성 세션 테이블 (ID, Path, Start Time, Status, Current Task, Actions)
- [ ] Session Management Actions
  - Stop 버튼 구현
  - View Details → Automation 페이지 라우팅
  - 우클릭 컨텍스트 메뉴
- [ ] DirectoryBrowser 통합
  - Orchestration에서 세션 시작용
  - Dashboard에서 tasks.db 경로 변경용 (기존 기능 유지)

### Phase 3: Session Persistence & Routing (Week 4)
- [ ] No-Timeout Session Management
  - 세션 지속성 보장 로직
  - 서버 재시작 시 세션 복구
  - 메모리 누수 방지
- [ ] Dynamic Routing Enhancement
  - `/automation/:sessionId` 라우팅 구현
  - 세션별 Automation 페이지 격리
  - 세션 간 상태 분리 보장
- [ ] WebSocket Session Namespacing
  - 세션ID 기반 이벤트 채널
  - 클라이언트별 세션 구독 관리

## Resource Management Strategy

### Session Persistence Policy
- **No Timeout**: 세션은 수동 종료 또는 서버 셧다운까지 지속
- **Manual Termination**: 사용자가 명시적으로 Stop 버튼 클릭
- **Server Restart Recovery**: 서버 재시작 시 활성 세션 목록 복구 시도
- **Memory Monitoring**: 시스템 메모리 부족 시 경고 표시

### Concurrent Session Management
- **Dynamic Scaling**: 하드웨어 리소스에 따른 동적 세션 수 조정
- **Resource Isolation**: 세션별 완전 독립적인 리소스 할당
- **Fair Resource Distribution**: 모든 세션에 균등한 CPU/메모리 접근
- **Session Status Tracking**: 실시간 세션 상태 모니터링 (running/idle/busy)

## WebSocket Architecture Enhancement

### Session-Based Event Namespacing
```javascript
// Dynamic Session Events
ws.send({ 
  type: 'task_update', 
  sessionId: 'uuid-session-123',
  data: {...} 
})

// Orchestration Events
ws.send({
  type: 'session_created',
  sessionId: 'uuid-session-123', 
  workingDirectory: '/path/to/directory'
})
```

### Multi-Session Subscription Management
- 클라이언트별 세션 구독 관리
- Orchestration 페이지: 모든 세션 통계 구독
- Automation 페이지: 특정 세션만 구독
- 동적 구독/구독해제 지원

## UX Flow Documentation

### Orchestration → Automation Flow
1. **Orchestration Page**:
   - 전체 세션 통계 표시 (Automation 스타일)
   - "Start Session" 버튼 클릭
   - DirectoryBrowser 팝업으로 디렉토리 선택
   - 새 세션 생성 → 테이블에 추가

2. **Session Management**:
   - 활성 세션 테이블: ID | Path | Start Time | Status | Current Task | Actions
   - Stop 버튼: 세션 즉시 종료
   - 우클릭 → "View Details" → `/automation/:sessionId` 라우팅

3. **Automation Page (Session-Specific)**:
   - 특정 세션의 독립적인 Automation 페이지
   - 해당 세션의 메시지 큐만 표시
   - 세션 간 완전 격리된 상태 관리

### DirectoryBrowser Integration
- **Orchestration**: 새 세션 시작용 디렉토리 선택
- **Dashboard**: tasks.db 경로 변경용 (기존 기능 유지)
- 동일한 컴포넌트, 다른 용도로 재사용

## Discovered Patterns

### Dynamic Orchestration Pattern
- 고정 구조 대신 완전히 동적인 세션 관리
- 사용자 주도적 워크플로우 지원
- 중앙화된 모니터링과 분산된 실행의 조합

### Session Persistence Pattern
- 타임아웃 없는 세션 지속성
- 수동 종료 방식의 명시적 제어
- 서버 재시작 내성을 위한 메타데이터 영속화

### UI Component Reuse Pattern  
- DirectoryBrowser의 다목적 활용
- Automation 스타일 통계 대시보드의 재사용
- 컨텍스트별 동일 컴포넌트 동작 분기

## Code References

### Current Implementation Files
- `server/index.js:1-185` - Main server setup
- `server/claude/session-manager.js` - 현재 단일 세션 관리
- `server/websocket/index.js` - WebSocket 핸들러
- `server/routes/api.js` - REST API 엔드포인트

### New Files to Create
- `server/orchestration/session-orchestrator.js` - 동적 세션 오케스트레이터
- `server/orchestration/session-instance.js` - 세션 인스턴스 모델
- `server/database/session-schema.sql` - 세션 메타데이터 스키마
- `src/pages/OrchestrationPage.jsx` - 세션 관리 대시보드
- `src/components/SessionTable.jsx` - 활성 세션 테이블

## Benefits Analysis

### Developer Experience
- **Ultimate Flexibility**: 어떤 디렉토리에서든 즉시 세션 시작
- **Persistent Sessions**: 작업 중단 없는 지속적 개발 환경
- **Central Monitoring**: 모든 활성 세션의 한눈에 보기
- **Independent Workspaces**: 세션 간 완전 격리된 작업 공간

### System Performance
- **Dynamic Resource Allocation**: 필요에 따른 세션 생성/해제
- **No Timeout Overhead**: 타임아웃 관리 오버헤드 제거
- **Session Isolation**: 세션별 독립적 처리로 간섭 최소화
- **Memory Persistence**: 세션 상태 유지로 재연결 비용 절약

### User Workflow Enhancement
- **Ad-hoc Session Creation**: 계획되지 않은 작업도 즉시 시작
- **Multi-tasking Support**: 여러 디렉토리에서 동시 작업
- **Simple Session Management**: 직관적인 테이블 기반 관리
- **Context Preservation**: 세션별 독립적 컨텍스트 보존

## Technical Challenges

### No-Timeout Session Management
- **Challenge**: 타임아웃 없는 지속성으로 인한 메모리 누수 위험
- **Solution**: 주기적 건강성 체크 및 가비지 컬렉션
- **Risk**: 장시간 유지 세션의 리소스 점유

### Dynamic Session Routing
- **Challenge**: 세션별 URL 라우팅 및 상태 격리
- **Solution**: React Router 동적 라우팅 + 세션 컨텍스트 관리
- **Risk**: 브라우저 새로고침 시 세션 연결 손실

### Session Recovery After Server Restart
- **Challenge**: 서버 재시작 시 활성 세션 복구
- **Solution**: 세션 메타데이터 영속화 + PTY 프로세스 재연결
- **Risk**: 복구 불가능한 세션 상태 손실

## Next Session

- [ ] SessionOrchestrator 기본 구조 구현 시작
- [ ] Dynamic Session 생성/종료 로직 설계
- [ ] Orchestration Page UI 모크업 작성
- [ ] Database 스키마 설계 (`active_sessions` 테이블)
- [ ] 기존 단일 세션 코드와의 통합 방식 검토

## Questions to Explore

1. 세션 지속성을 위한 최적의 메타데이터 저장 방식?
2. 서버 재시작 시 세션 복구 우선순위 정책?
3. Orchestration 페이지의 세션 테이블 실시간 업데이트 방식?
4. DirectoryBrowser 컴포넌트의 다목적 활용 인터페이스?
5. 세션별 메시지 큐 격리 구현 방법?

## Learning Notes

- **Dynamic Orchestration**: 고정된 구조 대신 완전히 유연한 세션 관리 패턴
- **No-Timeout Persistence**: 타임아웃 없는 세션 지속성의 장단점과 구현 고려사항
- **Component Reusability**: DirectoryBrowser 같은 UI 컴포넌트의 다목적 활용 전략
- **Session Isolation**: 세션별 완전 독립적 실행 환경 구축 방법
- **Architectural Pivot**: 프로젝트 기반에서 동적 오케스트레이션으로의 패러다임 전환

## Architecture Evolution Summary

**Before (Project-Based)**:
- 고정된 프로젝트-세션 매핑
- 타임아웃 기반 세션 관리
- 프로젝트 중심의 구조화된 접근

**After (Dynamic Orchestration)**:
- 완전히 동적인 세션 생성
- 사용자 주도적 워크플로우
- 지속성과 유연성 중심의 설계